# Implement the Paillier encryption scheme in Python. Encrypt two integers (e.g., 15 and 25)
# using your implementation of the Paillier encryption scheme. Print the ciphertexts. Perform
# an addition operation on the encrypted integers without decrypting them. Print the result of
# the addition in encrypted form. Decrypt the result of the addition and verify that it matches
# the sum of the original integers.
import random
from math import gcd

# ---- Key Generation ----
def lcm(x, y):
    return x * y // gcd(x, y)

def generate_keypair(p, q):
    n = p * q
    g = n + 1
    lam = lcm(p - 1, q - 1)
    mu = pow(lam, -1, n)
    return (n, g), (lam, mu)

# ---- Encryption ----
def encrypt(m, pub_key):
    n, g = pub_key
    r = random.randint(1, n - 1)
    while gcd(r, n) != 1:
        r = random.randint(1, n - 1)
    return (pow(g, m, n**2) * pow(r, n, n**2)) % (n**2)

# ---- Decryption ----
def decrypt(c, pub_key, priv_key):
    n, g = pub_key
    lam, mu = priv_key
    x = pow(c, lam, n**2)
    L = (x - 1) // n
    return (L * mu) % n

# ---- Demo ----
p, q = 53, 59  # small primes for demo
pub_key, priv_key = generate_keypair(p, q)

m1, m2 = 15, 25
c1 = encrypt(m1, pub_key)
c2 = encrypt(m2, pub_key)
print("Ciphertexts:", c1, c2)

# Homomorphic addition: E(m1+m2) = E(m1)*E(m2) mod n^2
c_add = (c1 * c2) % (pub_key[0] ** 2)
print("Encrypted sum:", c_add)

decrypted_sum = decrypt(c_add, pub_key, priv_key)
print("Decrypted sum:", decrypted_sum)



# Utilize the multiplicative homomorphic property of RSA encryption. Implement a basic
# RSA encryption scheme in Python. Encrypt two integers (e.g., 7 and 3) using your
# implementation of the RSA encryption scheme. Print the ciphertexts. Perform a
# multiplication operation on the encrypted integers without decrypting them. Print the result
# of the multiplication in encrypted form. Decrypt the result of the multiplication and verify
# that it matches the product of the original integers.

import random
from sympy import mod_inverse, isprime


class RSA:
    def __init__(self, bit_length=16):
        # Generate two distinct prime numbers p and q
        self.p = self.generate_prime(bit_length)
        self.q = self.generate_prime(bit_length)

        # Compute n as the product of p and q
        self.n = self.p * self.q

        # Calculate φ(n) = (p - 1)(q - 1)
        self.phi_n = (self.p - 1) * (self.q - 1)

        # Set e to a commonly used value, 65537
        self.e = 65537

        # Calculate d, the modular inverse of e mod φ(n)
        self.d = mod_inverse(self.e, self.phi_n)

    def generate_prime(self, bit_length):
        # Continuously generate random numbers until a prime is found
        while True:
            num = random.getrandbits(bit_length)  # Generate a random number of the specified bit length
            if isprime(num):  # Check if the number is prime
                return num  # Return the prime number

    def encrypt(self, plaintext):
        # Encrypt the plaintext using the public key (n, e)
        return pow(plaintext, self.e, self.n)

    def decrypt(self, ciphertext):
        # Decrypt the ciphertext using the private key (n, d)
        return pow(ciphertext, self.d, self.n)

    def multiply_encrypted(self, c1, c2):
        # Perform multiplication on two ciphertexts (homomorphic property)
        return (c1 * c2) % self.n


if __name__ == "__main__":
    # Instantiate the RSA cryptosystem
    rsa = RSA()

    # Encrypt two integers
    plaintext1 = 7
    plaintext2 = 3
    ciphertext1 = rsa.encrypt(plaintext1)
    ciphertext2 = rsa.encrypt(plaintext2)

    # Print the resulting ciphertexts
    print("Ciphertext 1:", ciphertext1)
    print("Ciphertext 2:", ciphertext2)

    # Perform multiplication on the encrypted integers
    encrypted_product = rsa.multiply_encrypted(ciphertext1, ciphertext2)
    print("Encrypted Product:", encrypted_product)

    # Decrypt the result of the multiplication
    decrypted_product = rsa.decrypt(encrypted_product)
    print("Decrypted Product:", decrypted_product)

    # Verify it matches the product of the original integers
    original_product = plaintext1 * plaintext2
    print("Original Product:", original_product)
    print("Verification:", decrypted_product == original_product)

