#  Execute the following for SSE:
# 1a. Create a dataset: Generate a text corpus of at least ten documents. Each document
# should contain multiple words.
# 1b. Implement encryption and decryption functions: Use the AES encryption and
# decryption functions.
# 1c. Create an inverted index: Build an inverted index mapping word to the list of
# document IDs containing those words.
# o Encrypt the index using the provided encryption function.
# 1d. Implement the search function:
# o Take a search query as input.
# o Encrypt the query.
# o Search the encrypted index for matching terms. 
# o Decrypt the returned document IDs and display the corresponding documents

import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from collections import defaultdict

# 1a. Generate text corpus
# List of documents to serve as our searchable text corpus.
documents = [
    "The wind howled through the empty streets on a cold evening.",
    "An orange cat sat silently under the oak tree, watching the world.",
    "Quantum computing may revolutionize cryptographic systems.",
    "Bright colors danced across the sky during the sunset .",
    "The spaceship drifted silently through the vast emptiness of space.",
    "Baking a cake requires precision and patience for the best results.",
    "The ancient ruins held secrets that no one had yet uncovered.",
    "Robots are becoming an essential part of modern manufacturing.",
    "A mysterious note was left on the doorstep in the dead of night.",
    "The evolution of technology is accelerating faster than ever before."
]


# Encryption & Decryption functions using AES
def get_aes_key():
    """Generate a deterministic AES key by hashing a password (or key) with SHA-256."""
    return hashlib.sha256(b"supersecretkey").digest()  # Using a fixed password for key generation


def encrypt(text, key):
    """Encrypt the given text using AES encryption in CBC mode with padding."""
    cipher = AES.new(key, AES.MODE_CBC)  # Create a new AES cipher in CBC mode
    ciphertext = cipher.encrypt(pad(text.encode("utf-8"), AES.block_size))  # Encrypt the padded text
    return cipher.iv + ciphertext  # Return the IV concatenated with the ciphertext


def decrypt(ciphertext, key):
    """Decrypt the given AES-encrypted ciphertext."""
    iv = ciphertext[: AES.block_size]  # Extract the initialization vector (IV)
    cipher = AES.new(key, AES.MODE_CBC, iv)  # Create a cipher using the IV
    decrypted = unpad(cipher.decrypt(ciphertext[AES.block_size:]), AES.block_size)  # Decrypt and unpad the text
    return decrypted.decode("utf-8")  # Return the decrypted plaintext


# 1c. Create inverted index using word hashes
def build_inverted_index(docs):
    """Build an inverted index where words (hashed) map to document IDs."""
    index = defaultdict(list)  # Initialize a defaultdict to store word hashes and corresponding doc IDs
    for doc_id, doc in enumerate(docs):  # Iterate over each document and its ID
        for word in doc.split():  # Split the document into words
            word_hash = hashlib.sha256(word.lower().encode("utf-8")).hexdigest()  # Hash each word in lowercase
            index[word_hash].append(doc_id)  # Map the word hash to the document ID
    return index  # Return the inverted index


# Encrypt document IDs
def encrypt_inverted_index(index, key):
    """Encrypt the document IDs in the inverted index using AES."""
    encrypted_index = {}  # Initialize an empty dictionary for the encrypted index
    for word_hash, doc_ids in index.items():  # Iterate over each word hash and its list of document IDs
        encrypted_index[word_hash] = encrypt(",".join(map(str, doc_ids)), key)  # Encrypt the list of doc IDs
    return encrypted_index  # Return the encrypted inverted index


# Decrypt inverted index results
def decrypt_inverted_index_results(encrypted_doc_ids, key):
    """Decrypt the encrypted document IDs and return them as a list of integers."""
    decrypted_doc_ids = decrypt(encrypted_doc_ids, key)  # Decrypt the ciphertext
    return list(map(int, decrypted_doc_ids.split(",")))  # Convert the decrypted string back to a list of integers


# 1d. Implement search function
def search(query, encrypted_index, key, documents):
    """Search for a query in the encrypted inverted index and return matching documents."""
    # Hash the search query (instead of encrypting) to find the corresponding word in the index
    query_hash = hashlib.sha256(query.lower().encode("utf-8")).hexdigest()  # Hash the query in lowercase
    if query_hash in encrypted_index:  # If the query hash exists in the encrypted index
        encrypted_doc_ids = encrypted_index[query_hash]  # Get the encrypted document IDs for the query
        doc_ids = decrypt_inverted_index_results(encrypted_doc_ids, key)  # Decrypt the document IDs
        return [documents[doc_id] for doc_id in doc_ids]  # Return the documents matching the document IDs
    else:
        return []  # Return an empty list if no matches are found


# Main execution block
if __name__ == "__main__":
    # Generate AES key
    aes_key = get_aes_key()  # Generate a deterministic AES key using SHA-256

    # Build and encrypt inverted index
    inverted_index = build_inverted_index(documents)  # Build the inverted index using word hashes
    encrypted_index = encrypt_inverted_index(inverted_index, aes_key)  # Encrypt the inverted index using AES

    # Take search query input and search
    query = input("Enter search query: ")  # Get search query from the user
    results = search(query, encrypted_index, aes_key, documents)  # Search the encrypted index for matching documents

    # Display results
    if results:  # If there are matching documents
        print("Documents matching query:")  # Print a header
        for result in results:  # Iterate over matching documents
            print(result)  # Print each matching document
    else:
        print("No matching documents found.")  # Print message if no documents are found

'''
Enter search query: sunset
Documents matching query:
Bright colors danced across the sky during the sunset .
'''



#  Execute the following for PKSE:
# 2a. Create a dataset:
# o Generate a text corpus of at least ten documents. Each document should contain
# multiple words.
# 2b. Implement encryption and decryption functions:
# o Use the Paillier cryptosystem for encryption and decryption.
# 2c. Create an encrypted index:
# o Build an inverted index mapping word to the list of document IDs containing
# those words.
# o Encrypt the index using the Paillier cryptosystem.
# 2d. Implement the search function:
# o Take a search query as input.
# o Encrypt the query using the public key.
# o Search the encrypted index for matching terms.
# o Decrypt the returned document IDs using the private key

import hashlib
from phe import paillier
from collections import defaultdict

# 2a. Generate text corpus
# A list of 10 sample documents (text corpus) is created to simulate a collection of textual data.
documents = [
    "The wind howled through the empty streets on a cold evening.",
    "An orange cat sat silently under the oak tree, watching the world.",
    "Quantum computing may revolutionize cryptographic systems.",
    "Bright colors danced across the sky during the sunset .",
    "The spaceship drifted silently through the vast emptiness of space.",
    "Baking a cake requires precision and patience for the best results.",
    "The ancient ruins held secrets that no one had yet uncovered.",
    "Robots are becoming an essential part of modern manufacturing.",
    "A mysterious note was left on the doorstep in the dead of night.",
    "The evolution of technology is accelerating faster than ever before."
]

# 2b. Paillier Encryption and Decryption functions
# Generate Paillier keypair (public and private keys) for homomorphic encryption
public_key, private_key = paillier.generate_paillier_keypair()


def word_to_hash(word):
    """Convert a word to a hash representation using SHA-256.

    Args:
        word (str): The word to be hashed.

    Returns:
        str: The hashed representation of the word.
    """
    return hashlib.sha256(word.encode("utf-8")).hexdigest()


def encrypt_ids(doc_ids, pub_key):
    """Encrypt document IDs using Paillier encryption.

    Args:
        doc_ids (list): List of document IDs to encrypt.
        pub_key (PaillierPublicKey): Public key used for encryption.

    Returns:
        list: Encrypted document IDs.
    """
    return [pub_key.encrypt(doc_id) for doc_id in doc_ids]


def decrypt_ids(encrypted_doc_ids, priv_key):
    """Decrypt encrypted document IDs using Paillier decryption.

    Args:
        encrypted_doc_ids (list): List of encrypted document IDs.
        priv_key (PaillierPrivateKey): Private key used for decryption.

    Returns:
        list: Decrypted document IDs.
    """
    return [priv_key.decrypt(enc_id) for enc_id in encrypted_doc_ids]


# 2c. Create inverted index
def build_inverted_index(docs):
    """Build an inverted index from the given documents.

    The inverted index maps hashed words to lists of document IDs where they occur.

    Args:
        docs (list): List of documents (strings).

    Returns:
        defaultdict: Inverted index mapping word hashes to lists of document IDs.
    """
    index = defaultdict(list)
    for doc_id, doc in enumerate(docs):
        for word in doc.split():
            index[word_to_hash(word.lower())].append(doc_id)
    return index


# Encrypt the document IDs in the inverted index
def encrypt_inverted_index(index, pub_key):
    """Encrypt the document IDs in the inverted index.

    Args:
        index (dict): Inverted index with word hashes as keys and lists of document IDs as values.
        pub_key (PaillierPublicKey): Public key used to encrypt document IDs.

    Returns:
        dict: Inverted index with encrypted document IDs.
    """
    encrypted_index = {}
    for word_hash, doc_ids in index.items():
        encrypted_index[word_hash] = encrypt_ids(doc_ids,
                                                 pub_key)  # creates a dict with word_hash as key and the corresponding doc_ids as encrypted
    return encrypted_index


# 2d. Implement search function
def search(query, encrypted_index, priv_key, documents):
    """Search for documents that match the given query.

    Args:
        query (str): Search query (word).
        encrypted_index (dict): Encrypted inverted index.
        priv_key (PaillierPrivateKey): Private key to decrypt document IDs.
        documents (list): List of original documents (strings).

    Returns:
        list: List of documents that match the query.
    """
    query_hash = word_to_hash(query.lower())

    if query_hash in encrypted_index:
        # Retrieve encrypted document IDs that match the query
        encrypted_doc_ids = encrypted_index[query_hash]

        # Decrypt document IDs to get original document indices
        doc_ids = decrypt_ids(encrypted_doc_ids, priv_key)

        # Return matching documents based on decrypted document IDs
        return [documents[doc_id] for doc_id in doc_ids]
    else:
        # No match found for the query
        return []


# Main execution
if __name__ == "__main__":
    # Build the inverted index using the sample documents
    inverted_index = build_inverted_index(documents)

    # Encrypt the inverted index using the public key
    encrypted_index = encrypt_inverted_index(inverted_index, public_key)

    # Take search query input from the user
    query = input("Enter search query: ")

    # Search the encrypted index and retrieve matching documents
    results = search(query, encrypted_index, private_key, documents)

    # Display results
    if results:
        print("Documents matching query:")
        for result in results:
            print(result)
    else:
        print("No matching documents found.")
