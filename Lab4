# SecureCorp is a large enterprise with multiple subsidiaries and business units located across
# different geographical regions. As part of their digital transformation initiative, the IT team at
# SecureCorp has been tasked with building a secure and scalable communication system to
# enable seamless collaboration and information sharing between their various subsystems.
# The enterprise system consists of the following key subsystems:
# 1. Finance System (System A): Responsible for all financial record-keeping, accounting, and
# reporting.
# 2. HR System (System B): Manages employee data, payroll, and personnel-related processes.
# 3. Supply Chain Management (System C): Coordinates the flow of goods, services, and
# information across the organization's supply chain.
# These subsystems need to communicate securely and exchange critical documents, such as
# financial reports, employee contracts, and procurement orders, to ensure the enterprise's
# overall efficiency.
# The IT team at SecureCorp has identified the following requirements for the secure
# communication and document signing solution:
# 1. Secure Communication: The subsystems must be able to establish secure communication
# channels using a combination of RSA encryption and Diffie-Hellman key exchange.
# 2. Key Management: SecureCorp requires a robust key management system to generate,
# distribute, and revoke keys as needed to maintain the security of the enterprise system.
# 3. Scalability: The solution must be designed to accommodate the addition of new subsystems
# in the future as SecureCorp continues to grow and expand its operations.
# Implement a Python program which incorporates the requirements.

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP, AES
from Crypto.Random import get_random_bytes
from Crypto.Util.number import getPrime
import time

class SecureCommunicationSystem:
    def __init__(self):
        self.subsystems = {}
        self.logs = []

    def create_system(self, subsystem_id):
        self.subsystems[subsystem_id] = {
            'shared_key': None,
            'private': get_random_bytes(32)  # Randomly generated private value for DH
        }
        self.log(f"{subsystem_id} created.")
        
    def log(self, message):
        self.logs.append(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}")
        print(message)

    def dh_key_exchange(self, sender_id, receiver_id):
        p = getPrime(2048)  # Generate a large prime number
        g = 2  # Use 2 as the base for DH

        # Sender's private key

        # Convert the sender's private key byte string to an integer
        a = int.from_bytes(self.subsystems[sender_id]['private'], 'big')  
        A = pow(g, a, p)  # Compute sender's public key

        # Receiver's private key
         # Convert the sender's private key byte string to an integer
        b = int.from_bytes(self.subsystems[receiver_id]['private'], 'big')
        B = pow(g, b, p)  # Compute receiver's public key

        # Compute the shared secret
        shared_secret_sender = pow(B, a, p)  # Sender computes shared secret
        shared_secret_receiver = pow(A, b, p)  # Receiver computes shared secret

        # Check if both computed shared secrets match
        if shared_secret_sender == shared_secret_receiver:
            # Reduce key size to fit AES requirements (16 bytes)
            shared_key = shared_secret_sender % (2 ** 128)
            self.subsystems[sender_id]['shared_key'] = shared_key
            self.subsystems[receiver_id]['shared_key'] = shared_key
            self.log(f"Shared key established between {sender_id} and {receiver_id}.")
        else:
            self.log("Failed to establish shared key.")

    def encrypt_message(self, sender_id, receiver_id, message):
        # Ensure sender has a shared key
        if sender_id not in self.subsystems or self.subsystems[sender_id]['shared_key'] is None:
            self.log(f"No shared key found for {sender_id}.")
            return None

        # Use the receiver's shared key for encryption
        shared_key = self.subsystems[receiver_id]['shared_key'].to_bytes(16, 'big')  
        cipher_aes = AES.new(shared_key, AES.MODE_EAX)  # Create a new AES cipher object in EAX mode
        ciphertext, tag = cipher_aes.encrypt_and_digest(message.encode())  # Encrypt the message and generate a tag
        # Return the concatenated nonce, tag, and ciphertext for decryption
        return cipher_aes.nonce + tag + ciphertext  

    def decrypt_message(self, receiver_id, encrypted_message):
        # Ensure receiver has a shared key
        if receiver_id not in self.subsystems or self.subsystems[receiver_id]['shared_key'] is None:
            self.log(f"No shared key found for {receiver_id}.")
            return None

        shared_key = self.subsystems[receiver_id]['shared_key'].to_bytes(16, 'big')  
        nonce = encrypted_message[:16]  # Extract the nonce from the encrypted message
        tag = encrypted_message[16:32]  # Extract the tag
        ciphertext = encrypted_message[32:]  # Extract the actual ciphertext

        # Create a new AES cipher object using the shared key and the extracted nonce
        cipher_aes = AES.new(shared_key, AES.MODE_EAX, nonce=nonce)  
        try:
            original_message = cipher_aes.decrypt_and_verify(ciphertext, tag).decode()
            self.log(f"Message decrypted for {receiver_id}.")
            return original_message  # Return the original decrypted message
        except ValueError:
            self.log("Decryption failed: MAC check failed.")
            return None

    def revoke_key(self, subsystem_id):
        # Revoke the keys associated with a given subsystem
        if subsystem_id in self.subsystems:
            del self.subsystems[subsystem_id]  # Remove subsystem from the dictionary
            self.log(f"Keys revoked for subsystem {subsystem_id}.")

# Example Usage:
secure_system = SecureCommunicationSystem()

# Generate RSA keys for subsystems
secure_system.create_system("Finance System")
secure_system.create_system("HR System")
secure_system.create_system("Supply Chain Management")

# Establish secure communication using Diffie-Hellman key exchange
secure_system.dh_key_exchange("Finance System", "HR System")
secure_system.dh_key_exchange("Supply Chain Management", "HR System")
secure_system.dh_key_exchange("Supply Chain Management", "Finance System")

# Encrypt a message from Finance to HR
encrypted_msg = secure_system.encrypt_message("Finance System", "HR System", "Confidential financial report.")

# Decrypt the message at HR
original_message = secure_system.decrypt_message("HR System", encrypted_msg)
if original_message is not None:
    print(f"Decrypted Message: {original_message}")
else:
    print("Failed to decrypt the message.")
    
# Revoking keys (if necessary)
secure_system.revoke_key("Finance System")



# HealthCare Inc., a leading healthcare provider, has implemented a secure patient data
# management system using the Rabin cryptosystem. The system allows authorized healthcare
# 38
# Database and Domain Name Servers (DNS)
# professionals to securely access and manage patient records across multiple hospitals and
# clinics within the organization. Implement a Python-based centralized key management
# service that can:
# • Key Generation: Generate public and private key pairs for each hospital and clinic using
# the Rabin cryptosystem. The key size should be configurable (e.g., 1024 bits).
# • Key Distribution: Provide a secure API for hospitals and clinics to request and receive
# their public and private key pairs.
# • Key Revocation: Implement a process to revoke and update the keys of a hospital or
# clinic when necessary (e.g., when a facility is closed or compromised).
# • Key Renewal: Automatically renew the keys of all hospitals and clinics at regular
# intervals (e.g., every 12 months) to maintain the security of the patient data management
# system.
# • Secure Storage: Securely store the private keys of all hospitals and clinics, ensuring that
# they are not accessible to unauthorized parties.
# • Auditing and Logging: Maintain detailed logs of all key management operations, such
# as key generation, distribution, revocation, and renewal, to enable auditing and
# compliance reporting.
# • Regulatory Compliance: Ensure that the key management service and its operations are
# compliant with relevant data privacy regulations (e.g., HIPAA).
# • Perform a trade-off analysis to compare the workings of Rabin and RSA.

import random
import json
import os
from datetime import datetime, timedelta
from sympy import isprime

# Directory for storing keys and logs


KEY_DIRECTORY = 'C:/Users/HP/OneDrive/Desktop/Coding/Python/Python learning/keys'  # change path

# Key expiry interval set to 365 days
KEY_EXPIRY_INTERVAL = timedelta(days=365)

# Ensure the key directory exists; if not, create it
if not os.path.exists(KEY_DIRECTORY):
    os.makedirs(KEY_DIRECTORY)


# Function to generate a large prime number
def generate_large_prime(bits):
    while True:
        # Generate a random number with the specified number of bits
        p = random.getrandbits(bits)
        # Check if the number is prime
        if isprime(p):
            return p  # Return the prime number if found


# Rabin key pair generation
def rabin_key_pair(bits):
    # Generate two large prime numbers p and q
    p = generate_large_prime(bits // 2)
    q = generate_large_prime(bits // 2)
    n = p * q  # Calculate n as the product of p and q
    public_key = n  # Public key is n
    private_key = (p, q)  # Private key is a tuple of (p, q)

    return public_key, private_key  # Return the keys


# Rabin encryption function
def encrypt_rabin(public_key, plaintext):
    n = public_key  # Public key
    # Encrypt plaintext using Rabin encryption formula
    return (plaintext ** 2) % n


# Rabin decryption function
def decrypt_rabin(private_key, ciphertext):
    p, q = private_key  # Extract p and q from the private key
    n = p * q  # Calculate n

    # Calculate square roots of ciphertext modulo p and q
    sqrt_p1 = pow(ciphertext, (p + 1) // 4, p)
    sqrt_p2 = (p - sqrt_p1) % p
    sqrt_q1 = pow(ciphertext, (q + 1) // 4, q)
    sqrt_q2 = (q - sqrt_q1) % q

    # Combine the results to get all possible plaintext candidates
    plaintext_candidates = [
        (sqrt_p1 * sqrt_q1) % n,
        (sqrt_p1 * sqrt_q2) % n,
        (sqrt_p2 * sqrt_q1) % n,
        (sqrt_p2 * sqrt_q2) % n
    ]

    return plaintext_candidates  # Return the candidates


# Class to manage key generation, storage, and revocation
class KeyManager:
    def __init__(self):
        self.keys = {}  # Dictionary to store keys
        self.load_keys()  # Load existing keys from the file

    # Key pair generation for a facility
    def generate_key_pair(self, facility_id, bits=1024):
        public_key, private_key = rabin_key_pair(bits)  # Generate key pair
        # Store keys along with metadata (creation and expiry dates)
        self.keys[facility_id] = {
            'public_key': public_key,
            'private_key': private_key,
            'creation_date': datetime.now().isoformat(),
            'expiry_date': (datetime.now() + KEY_EXPIRY_INTERVAL).isoformat()
        }
        self.save_keys()  # Save the updated keys to a file
        # Log the key generation event
        self.audit_log('Key Generation', f"Generated key pair for facility {facility_id}")
        return public_key, private_key  # Return the generated keys

    # Retrieve the key pair for a specific facility
    def get_key_pair(self, facility_id):
        key_data = self.keys.get(facility_id)  # Get key data for the facility
        # Check if the key is found and not expired
        if key_data and datetime.now() < datetime.fromisoformat(key_data['expiry_date']):
            return key_data['public_key'], key_data['private_key']  # Return keys
        else:
            raise ValueError("Key not found or expired")  # Raise an error if not found or expired

    # Revoke the key for a specific facility
    def revoke_key(self, facility_id):
        if facility_id in self.keys:
            del self.keys[facility_id]  # Delete the key for the facility
            self.save_keys()  # Save the updated keys to a file
            # Log the key revocation event
            self.audit_log('Key Revocation', f"Revoked key pair for facility {facility_id}")
        else:
            raise ValueError("Key not found")  # Raise an error if not found

    # Renew keys for all facilities if expired
    def renew_keys(self):
        for facility_id, key_data in list(self.keys.items()):
            # Check if the key is expired
            if datetime.now() >= datetime.fromisoformat(key_data['expiry_date']):
                self.generate_key_pair(facility_id)  # Re-generate for renewal
                # Log the key renewal event
                self.audit_log('Key Renewal', f"Renewed key pair for facility {facility_id}")

    # Save keys to a JSON file
    def save_keys(self):
        with open(os.path.join(KEY_DIRECTORY, 'keys.json'), 'w') as f:
            json.dump(self.keys, f, indent=4)  # Write the keys to the file in JSON format

    # Load keys from a JSON file
    def load_keys(self):
        key_file = os.path.join(KEY_DIRECTORY, 'keys.json')  # Path to the key file
        if os.path.exists(key_file):
            with open(key_file, 'r') as f:
                self.keys = json.load(f)  # Load keys from the file

    # Audit logging function
    def audit_log(self, action, details):
        # Append log entries to the audit log file
        with open(os.path.join(KEY_DIRECTORY, 'audit.log'), 'a') as f:
            f.write(f"{datetime.now()} - {action}: {details}\n")


# Example Usage
if __name__ == "__main__":
    key_manager = KeyManager()  # Initialize the key manager

    facility_id = 'hospital_123'  # Example facility ID
    # Generate key pair for the facility
    public_key, private_key = key_manager.generate_key_pair(facility_id)
    print(f"Generated keys for {facility_id}:")
    print(f"Public Key: {public_key}")
    print(f"Private Key: {private_key}")

    # Get key pair and demonstrate encryption/decryption
    pub_key, priv_key = key_manager.get_key_pair(facility_id)  # Retrieve the keys
    plaintext = 12345  # Example plaintext
    # Encrypt the plaintext
    encrypted = encrypt_rabin(pub_key, plaintext)
    print(f"Encrypted: {encrypted}")

    # Decrypt the ciphertext
    decrypted_candidates = decrypt_rabin(priv_key, encrypted)
    print(f"Decrypted candidates: {decrypted_candidates}")

    # Check which candidate matches the original plaintext
    for pt in decrypted_candidates:
        if pt == plaintext:
            decrypted_plaintext = pt
            break
        else:
            decrypted_plaintext = None

    # Verify if decryption was successful
    if decrypted_plaintext is not None:
        print(f"Decrypted to original plaintext: {decrypted_plaintext}")
    else:
        print("Decryption did not yield the original plaintext.")

    # Renew keys for all facilities
    key_manager.renew_keys()

    # Revoke the key for the facility
    key_manager.revoke_key(facility_id)

    # Display keys to verify revocation
    print("Keys after revocation:")
    print(key_manager.keys)



#additional 1
# DigiRights Inc. is a leading provider of digital content, including e-books, movies, and music.
# The company has implemented a secure digital rights management (DRM) system using the
# ElGamal cryptosystem to protect its valuable digital assets. Implement a Python-based
# centralized key management and access control service that can:
# • Key Generation: Generate a master public-private key pair using the ElGamal
# cryptosystem. The key size should be configurable (e.g., 2048 bits).
# • Content Encryption: Provide an API for content creators to upload their digital content and
# have it encrypted using the master public key.
# • Key Distribution: Manage the distribution of the master private key to authorized
# customers, allowing them to decrypt the content.
# • Access Control: Implement flexible access control mechanisms, such as:
# o Granting limited-time access to customers for specific content
# o Revoking access to customers for specific content
# o Allowing content creators to manage access to their own content
# • Key Revocation: Implement a process to revoke the master private key in case of a security
# breach or other emergency.
# • Key Renewal: Automatically renew the master public-private key pair at regular intervals
# (e.g., every 24 months) to maintain the security of the DRM system.
# • Secure Storage: Securely store the master private key, ensuring that it is not accessible to
# unauthorized parties.
# • Auditing and Logging: Maintain detailed logs of all key management and access control
# operations to enable auditing and troubleshooting.


from Crypto.PublicKey import ElGamal
from Crypto.Random import get_random_bytes
from Crypto.Hash import SHA256
import os
import time
import json
from threading import Timer

class DRMSystem:
    def __init__(self, key_size=2048):
        # Initialize the DRM system with a specified key size
        self.key_size = key_size
        self.master_key_pair = None  # To hold the master public-private key pair
        self.content_keys = {}  # To map content IDs to their encrypted content
        self.access_control = {}  # To manage access rights for customers
        self.logs = []  # To store logs of operations
        self.key_renewal_interval = 60 * 60 * 24 * 30  # Set key renewal interval to 30 days
        self.start_key_renewal()  # Start the automatic key renewal process

    def generate_master_key(self):
        """Generates a master public-private key pair using the ElGamal cryptosystem."""
        self.master_key_pair = ElGamal.generate(self.key_size, get_random_bytes)
        self.log("Master key pair generated.")

    def encrypt_content(self, content_id, content):
        """Encrypts the given content using the master public key.

        Args:
            content_id (str): Unique identifier for the content.
            content (bytes): The content to be encrypted.
        """
        h = SHA256.new(content).digest()  # Create a hash of the content
        encrypted_content = self.master_key_pair.encrypt(h, get_random_bytes(16))  # Encrypt the hash
        self.content_keys[content_id] = encrypted_content  # Store the encrypted content
        self.log(f"Content {content_id} encrypted.")

    def distribute_key(self, customer_id, content_id):
        """Grants limited-time access to customers for specific content.

        Args:
            customer_id (str): Unique identifier for the customer.
            content_id (str): Unique identifier for the content.
        """
        # Example access control: Limited-time access for 1 hour
        self.access_control[(customer_id, content_id)] = time.time() + 3600  # Set access expiration
        self.log(f"Access granted to {customer_id} for content {content_id}.")

    def revoke_access(self, customer_id, content_id):
        """Revokes access for a specific customer to specific content.

        Args:
            customer_id (str): Unique identifier for the customer.
            content_id (str): Unique identifier for the content.
        """
        if (customer_id, content_id) in self.access_control:
            del self.access_control[(customer_id, content_id)]  # Remove access entry
            self.log(f"Access revoked for {customer_id} for content {content_id}.")

    def key_revocation(self):
        """Revokes the master key and generates a new one."""
        self.generate_master_key()  # Generate a new master key pair
        self.log("Master key revoked and renewed.")

    def check_access(self, customer_id, content_id):
        """Checks if a customer has access to specific content.

        Args:
            customer_id (str): Unique identifier for the customer.
            content_id (str): Unique identifier for the content.

        Returns:
            bool: True if access is granted, False otherwise.
        """
        if (customer_id, content_id) in self.access_control:
            access_time = self.access_control[(customer_id, content_id)]
            if time.time() <= access_time:  # Check if access is still valid
                return True
        return False

    def secure_store_key(self):
        """Securely stores the master private key."""
        with open("private_key.pem", "wb") as f:
            f.write(self.master_key_pair.export_key())  # Export the master key to a file
        os.chmod("private_key.pem", 0o600)  # Restrict access to the private key file
        self.log("Master private key securely stored.")

    def log(self, message):
        """Logs actions and operations in the DRM system.

        Args:
            message (str): The message to be logged.
        """
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')  # Get the current timestamp
        log_entry = f"{timestamp} - {message}"  # Create a log entry
        self.logs.append(log_entry)  # Append the log entry to the log list
        print(log_entry)  # For demonstration purposes, print the log entry

    def start_key_renewal(self):
        """Starts a timer to automatically renew keys at regular intervals."""
        Timer(self.key_renewal_interval, self.renew_keys).start()  # Set a timer to renew keys

    def renew_keys(self):
        """Renews the master public-private key pair."""
        self.key_revocation()  # Revoke the current key and generate a new one
        self.start_key_renewal()  # Restart the key renewal timer

    def save_logs(self):
        """Saves logs to a file for auditing purposes."""
        with open("drm_logs.json", "w") as f:
            json.dump(self.logs, f, indent=4)  # Write logs to a JSON file

# Example Usage
if __name__ == "__main__":
    drm = DRMSystem()  # Create an instance of the DRM system
    drm.generate_master_key()  # Generate the master key pair
    drm.encrypt_content("content1", b"Some digital content")  # Encrypt some content
    drm.distribute_key("customer1", "content1")  # Grant access to a customer
    drm.revoke_access("customer1", "content1")  # Revoke access for the customer
    drm.key_revocation()  # Renew the master key
    drm.secure_store_key()  # Securely store the master private key
    drm.save_logs()  # Save logs at the end of operations



#additional 2
# Suppose that XYZ Logistics has decided to use the RSA cryptosystem to secure their sensitive
# communications. However, the security team at XYZ Logistics has discovered that one of their
# employees, Eve, has obtained a partial copy of the RSA private key and is attempting to
# recover the full private key to decrypt the company's communications.
# Eve's attack involves exploiting a vulnerability in the RSA key generation process, where the
# prime factors (p and q) used to generate the modulus (n) are not sufficiently large or random.
# Develop a Python script that can demonstrate the attack on the vulnerable RSA cryptosystem
# and discuss the steps to mitigate the attack.

from Crypto.PublicKey import RSA
from Crypto.Util.number import inverse, getPrime
from Crypto.Random import get_random_bytes
import math


def weak_rsa_key_generation():
    """Generates a weak RSA key with small prime factors."""
    # Use small primes for demonstration purposes (not secure)
    p = 61  # Small prime
    q = 53  # Small prime
    n = p * q  # RSA modulus
    phi = (p - 1) * (q - 1)  # Euler's totient
    e = 65537  # Commonly used public exponent

    # Calculate the private exponent d
    d = inverse(e, phi)
    return n, e, d, p, q


def factor_n(n):
    """Attempts to factor the modulus n into its prime factors."""
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return i, n // i  # Return the factors (p, q)
    return None


def encrypt_message(n, e, message):
    """Encrypts the message using the public key (n, e)."""
    message_bytes = message.encode('utf-8')
    m = int.from_bytes(message_bytes, byteorder='big')
    c = pow(m, e, n)  # Ciphertext
    return c


def decrypt_message(c, d, n):
    """Decrypts the ciphertext using the private key (d)."""
    m = pow(c, d, n)  # Decrypted message
    # Convert back to bytes, ensuring we properly handle the byte length
    byte_length = (n.bit_length() + 7) // 8  # Calculate byte length of n
    return m.to_bytes(byte_length, byteorder='big').decode('utf-8').rstrip('\x00')  # Decode and strip null bytes


# Demonstrating the attack
if __name__ == "__main__":
    # Step 1: Generate a weak RSA key
    n, e, d, p, q = weak_rsa_key_generation()
    print(f"Weak RSA key generated with n = {n}, e = {e}")

    # Step 2: Eve attempts to factor n
    print("Eve attempts to factor n...")
    factors = factor_n(n)

    if factors:
        print(f"Eve successfully factors n: p = {factors[0]}, q = {factors[1]}")

        # Step 3: Recover the private key (d)
        recovered_d = inverse(e, (factors[0] - 1) * (factors[1] - 1))
        print(f"Eve recovers the private key d = {recovered_d}")

        # Step 4: Encrypt a message using the public key
        message = "Confidential Information"
        ciphertext = encrypt_message(n, e, message)
        print(f"Ciphertext: {ciphertext}")

        # Step 5: Decrypt the message using the recovered private key
        decrypted_message = decrypt_message(ciphertext, recovered_d, n)
        print(f"Decrypted message: {decrypted_message}")
    else:
        print("Eve failed to factor n.")
